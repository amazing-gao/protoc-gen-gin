package main

import (
	"bytes"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"google.golang.org/genproto/googleapis/api/annotations"
)

type (
	// Generator godoc
	Generator struct {
		*bytes.Buffer
		Request           *plugin.CodeGeneratorRequest  // The input.
		Response          *plugin.CodeGeneratorResponse // The output.
		Param             map[string]string             // Command-line parameters.
		PackageImportPath string                        // Go import path of the package we're generating code for
		ImportPrefix      string                        // String to prefix to imported package file names.
		ImportMap         map[string]string             // Mapping from .proto file name to import path
		Pkg               map[string]string             // The names under which we import support packages

		imports  []string                        // 程序导入
		file     *descriptor.FileDescriptorProto // 正在处理的协议文件描述信息
		fileName string                          // 正在处理的文件名
		filePkg  string                          // 正在处理的包名
	}
)

const (
	// GeneratorName godoc
	GeneratorName = "protoc-gen-box"
)

// New godoc
func New() *Generator {
	g := new(Generator)
	g.Buffer = new(bytes.Buffer)
	g.Request = new(plugin.CodeGeneratorRequest)
	g.Response = new(plugin.CodeGeneratorResponse)

	return g
}

// GenerateAllFiles godoc
func (g *Generator) GenerateAllFiles() {
	for _, file := range g.Request.GetProtoFile() {
		g.Reset()

		g.file = file
		g.fileName = file.GetName()
		g.filePkg = file.GetPackage()

		if !g.canGenerate(g.fileName) {
			continue
		}

		g.importDefault()
		g.genCommentHead()
		g.genPackageName()
		g.genImports()
		g.genSvcInterface()
		g.genSvcImplement()
		g.genSvcRegister()

		g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(FillPath(g.fileName)),
			Content: proto.String(g.String()),
		})
	}
}

func (g *Generator) importDefault() {
	g.addImport("context")
	g.addImport("github.com/gin-gonic/gin")
	g.addImport("github.com/gin-gonic/gin/binding")
}

func (g *Generator) addImport(pkg ...string) {
	g.imports = append(g.imports, pkg...)
}

func (g *Generator) genCommentHead() {
	g.F("// Code generated by %s. DO NOT EDIT.", GeneratorName)
	g.F("// source: %s", g.fileName)
	g.P("")
}

func (g *Generator) genPackageName() {
	g.F("package %s", g.filePkg)
	g.P("")
}

func (g *Generator) genImports() {
	if len(g.imports) == 0 {
		return
	}

	g.P("import (")
	for _, ipt := range g.imports {
		g.F("	\"%s\"", ipt)
	}
	g.P(")")
	g.P("")
}

func (g *Generator) genSvcInterface() {
	for _, svc := range g.file.GetService() {
		g.F("type %s interface {", g.convertToServerInterfaceTypeName(svc))

		for _, method := range svc.GetMethod() {
			inType := totype(g.filePkg, method.GetInputType())
			outType := totype(g.filePkg, method.GetOutputType())

			g.F("	%s(ctx context.Context, req *%s) (resp *%s, err error)", method.GetName(), inType, outType)
		}

		g.P("}")
	}
}

func (g *Generator) genSvcImplement() {
	g.P("")

	for _, svc := range g.file.GetService() {
		for _, method := range svc.GetMethod() {
			inType := totype(g.file.GetPackage(), method.GetInputType())

			g.F(`func %s%s(svc %s) func(ctx *gin.Context) {`, svc.GetName(), method.GetName(), g.convertToServerInterfaceTypeName(svc))
			g.P("	return func(ctx *gin.Context) {")
			g.F("		req := &%s{}", inType)
			g.P(`		if err := ctx.ShouldBindWith(req, binding.Default(ctx.Request.Method, ctx.Request.Header.Get("Content-Type"))); err != nil {`)
			g.P("			ctx.JSON(400, err)")
			g.P("			ctx.Abort()")
			g.P("			return")
			g.P("		}")
			g.P("")
			g.F("		if resp, err := svc.%s(ctx, req); err != nil {", method.GetName())
			g.P("			ctx.JSON(500, err)")
			g.P("			ctx.Abort()")
			g.F("		} else {")
			g.P("			ctx.JSON(200, resp)")
			g.P("		}")
			g.P("	}")
			g.P("}")
		}
	}
}

func (g *Generator) genSvcRegister() {
	g.P("")
	for _, svc := range g.file.GetService() {
		name := g.convertToServerInterfaceTypeName(svc)
		g.F(`func Register%s(engine *gin.Engine, server %s) {`, name, name)

		for _, method := range svc.GetMethod() {
			ext, _ := proto.GetExtension(method.GetOptions(), annotations.E_Http)
			rule := ext.(*annotations.HttpRule)

			var httpMethod string
			var pathPattern string
			switch pattern := rule.Pattern.(type) {
			case *annotations.HttpRule_Get:
				pathPattern = pattern.Get
				httpMethod = http.MethodGet
			case *annotations.HttpRule_Put:
				pathPattern = pattern.Put
				httpMethod = http.MethodPut
			case *annotations.HttpRule_Post:
				pathPattern = pattern.Post
				httpMethod = http.MethodPost
			case *annotations.HttpRule_Patch:
				pathPattern = pattern.Patch
				httpMethod = http.MethodPatch
			case *annotations.HttpRule_Delete:
				pathPattern = pattern.Delete
				httpMethod = http.MethodDelete
			default:
			}

			g.F("	engine.%s(\"%s\", %s%s(server))", httpMethod, pathPattern, svc.GetName(), method.GetName())
		}

		g.P("}")
	}
}

func (g *Generator) canGenerate(name string) bool {
	ok := false

	for _, f := range g.Request.GetFileToGenerate() {
		if f == name {
			ok = true
			break
		}
	}

	return ok
}

// convertToServerInterfaceTypeName 服务名称（协议中：{{service}}+GinService）
func (g *Generator) convertToServerInterfaceTypeName(service *descriptor.ServiceDescriptorProto) string {
	return service.GetName() + "GinServer"
}

// Reset godoc
func (g *Generator) Reset() {
	g.Buffer.Reset()
	g.file = nil
	g.fileName = ""
	g.filePkg = ""
}

// P godoc
func (g *Generator) P(strs ...string) {
	for _, str := range strs {
		g.F(str)
	}
}

// F godoc
func (g *Generator) F(format string, args ...interface{}) {
	content := fmt.Sprintf(format, args...)

	g.WriteString(content)
	g.WriteString("\n")
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-go: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-go: error:", s)
	os.Exit(1)
}
